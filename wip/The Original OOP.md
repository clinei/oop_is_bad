# The Original OOP

Object Oriented Programming, as originally described by Alan Kay and others, imagines programming as modeling interactions between entities by passing information by value as messages. Every entity (object) can receive any message, and can route the message to be handled by a different method than the sender intended. The receiver has more control over the result and control flow than the sender. OOP was actually what is now called distributed computing, but inside a single machine. That's very different from the way it's usually implemented, and how it is taught in most schools, which is synchronous calls with object parameters passed by reference. Direct control over the flow of the program, and direct control over other objects through references, is in stark contrast with the original idea of not storing links to the physical location of the object, or knowing the full interface of the object. Erlang implemented the message passing version of OOP as part of a functional language, as did Scheme and Scala. Why C++, Java, and C# went with a version of OOP that [the original inventor doesn't recognize as OOP under any definition](https://www.quora.com/What-is-Alan-Kays-definition-of-Object-Oriented/). He specifically fights against encapsulation and information hiding as the core ideas, because that gets in the way of efficiently routing the messages. The goal is to make it easy to simulate interactions between entities, not creating a mess of constraints that are hard to satisfy. The goal was to make rapid prototyping easy by making it easy to bang lots of ideas together and see what comes out. It was made to be simple for kids to understand, as part of the personal computing revolution designed in Xerox Parc. The goal was to abstract away just enough to be able to focus on the "what", not the "how", and rapidly iterate. While this can be done for very small codebases, for which other methods are more appropriate, most of the time working on big C++ style OOP codebases is spent on finding ways to route information to the right places, and figuring out how to craft the right messages to make many picky receivers work together and do something useful, instead of quickly banging ideas together and seeing what comes out. Pieces of code, our rigid, written versions of ideas, just don't mash as well as our less pedantic minds would think.

Here is [what Alan Kay thinks about inheritance](https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming) 
(he has many alternatives in mind, and considers it a lesser idea that didn't really pan out)

Virtual tables, also known as vtables, is the main way that the implementation of abstract interfaces, inheritance, and polymorphism are taught, because that's what C++, Java, and C# do. They have a lot of problems, especially performance-related ones, which are iterated in [this article](./The Performance of OOP). Some of this can be fixed by extra work on your part, but not always. There are better ways to implement inheritance, like [prototype-based inheritance in Javascript](https://dev.to/crishanks/classical-vs-prototypal-inheritance-2o5a), or even better, some kind of Entity-Component-System, or better yet, just plain [tables](https://www.oocities.org/tablizer/top.htm) and [Data Oriented Programming](http://www.dataorienteddesign.com/dodbook/node2.html).

The creators of Design Patterns, a popular idea among modern OOP programmers, warn against naively reusing implementations through inheritance, and [instead recommend using composition](https://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29#Issues_and_alternatives), in which the superclass is a data member of the subclass and has full control over which implementation is used when, unlike inheritance, where any superclass in the hierarchy can mess with your intended result.

Polymorphism is closer to the idea of messaging and not caring about who the sender is, or who handles the message. But it is more usable and powerful in [prototype-based](https://dev.to/crishanks/classical-vs-prototypal-inheritance-2o5a) and [data oriented](http://www.dataorienteddesign.com/dodbook/node4.html#SECTION00480000000000000000) solutions.

And with that, I hope that you have a better idea of what OOP was supposed to be, why it's not, and what to do instead.