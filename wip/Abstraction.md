# Abstraction

It's true that good abstractions can help decrease the complexity of large programs. But creating too many abstractions at too small scales has the opposite effect. Abstraction adds some complexity to remove some other complexity. When the complexity removed is smaller than the complexity added, the result is more complexity than what you had before. That's what eventually happens in OOP.

Modeling software components according to real-world analogues has a problem: when we try to make our system behave like the real world, or more precisely, our current understanding of it, we add unnecessary constraints that are unrelated to a specific problem. It also increases the scope of the problem: instead of just making the system do something specific, we have to generalize for cases we don't actually have. This leads to over-abstraction and systems that are hard to understand. Also, many things in programming don't have a real world analogue, and when they do, they might not match with someone else's idea of the world. We also have to think about what our components are, not just what they do. We have to invent a system of ontology and categories that we don't actually need.

That means that instead of letting us think more freely in terms of real world objects and use cases, OOP imprisons us in a nightmare of over-abstraction and bureaucracy. Encapsulating data and behavior into frameworks such that you couldn't do anything meaningful without them is bad. This is the banana-monkey-jungle problem. Every time you encapsulate a problem into classes, you create a required order of operations and forced data layout. This is why OOP makes reuse harder, not easier. Even if we use polymorphism, the way we can do it is decided by the library. Very tight coupling and only the illusion of flexibility.

That is not to say that encapsulation is always bad. Encapsulation, when done at the level of modules, can be very useful in shielding the program outside the module from changes inside the module. But it always has a cost. At the level of single data units, that cost is almost always too big. The reason why large OOP systems are hard to understand is because all those abstractions make it hard to think about what the program actually does, not the code size. OOP does tend to increase the amount of code you need to get something done, though.

You should not try to closely model the real world. You should only solve the problem at hand, and not add your specific worldview into the problem statement. In the program, you have superpowers. Why should you limit yourself by adding unnecessary constraints? Without them, you will have a lot less code to write, it will be much easier to read and change, and it will be a lot more reusable and performant. If you rewrote Windows 10 in a purely procedural way, with encapsulation at the level of modules instead of single data units, it would be about 20 million lines.

There is no good argument for OOP in terms of code quality and programmer productivity. The only benefit is when you have a lot of mediocre programmers and bad planning and communication and a big budget, and you don't care about performance or maintainability. Most large software companies seem to be like that, so it makes sense for them to use OOP. But they should own it, not believe that they are actually writing good code.

As an example, imagine that the following code is for a system that does something really complex. Does OOP help manage that complexity, or does it add more?
https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition/blob/master/src/main/java/com/seriouscompany/business/java/fizzbuzz/packagenamingpackage/impl/loop/LoopRunner.java
