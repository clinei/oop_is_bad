# The Effect of Classes on Program Structure

The implementation and use of a class is limited by the division of labor into methods, and the order of method calls that get the data into a valid state, and also the types of the parameters and return values of the methods, and the types of the data members.The implementation of a specific method is limited by the expected state of the object when entering and exiting the method and what the other methods are supposed to do. That's a lot of implicit rules in one place. And the all interact strongly with eachother. But maybe that's fine.

> Separate state and logic

It is easier to structure a program when there are few possible centers of control, and when they are at the beginning of the specific behavior. When there are only a few rules that everyone has to follow, there is little confusion about what the correct solution should be. Ideally, that means that the hard decisions are done at the beginning of the behavior, and everyone else just reuses those decisions. This leaves little room for error in control flow and state changes, and decreases complexity. It also makes it easier to find and fix bugs.

When the behavior changes, the optimal responsibility over the data changes too. Sometimes the data is generated outside of the system, and needs to be checked for consistency. Sometimes the data is trusted and can be used with no validation. Sometimes the memory for the data should be freed right after it has been used. Sometimes it needs stay around. The vast amount of different use cases means that there is no single way to correctly manage responsibility over data.

Classes make the responsibility static and create too many possible centers of control. By binding state and behavior together, they create a powerful but overly specific point of abstraction. They give the programmer too much power to reinterpret things, which might be fine, except they don't actually need that power there and don't have access to all the necessary data. Good abstractions are designed for the behavior and data of the entire system. Good abstractions are small and simple, don't have too many special contexts, and work well with other abstractions in the system. Good abstractions usually work in the context of the entirety of the behavior. If your program is too confusing even for yourself, you are probably using too many abstractions of the wrong kind, in the wrong way, in the wrong place. Classes are really good at creating such abstractions.

When there are too many possible centers of control, and they all seem equally eligible, the power struggle can result in higher complexity, more state, and more confusing program structure. To solve the problem, a committee of mediators are created, more possible centers of control, and the cycle continues. Too many possible centers of control also makes it more tempting to cover up the mistakes of previous centers of control instead of dealing with the root problem, which also increases complexity and might cause more problems instead of fixing them. This is the reason why functional programming tries to use pure functions and value types as much as possible, because it creates single centers of control that eliminate the ability to cover up problems and forces us to actually fix them.
